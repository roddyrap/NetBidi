<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Net.Http.dll" #>
<#@ import namespace="System.Net.Http" #>
<#@ assembly name="System.Runtime" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ assembly name="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="System.Text.RegularExpressions.dll" #>
<#
// Get the unicode data from the web.
string GetWebFile(string url) {
    using (HttpClient client = new())
    {
        var httpTask = Task.Run(() => client.GetAsync(url)); 
        httpTask.Wait();

        HttpResponseMessage responseMessage = httpTask.Result ?? throw new Exception("Failed to get unicode file");
        responseMessage.EnsureSuccessStatusCode();
        
        var readTask = Task.Run(() => responseMessage.Content.ReadAsStringAsync());
        readTask.Wait();

        return readTask.Result;
    }
}#>
<#
string mirroringFileString = GetWebFile("https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt");
string bracketsFileString = GetWebFile("https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt");
string bidiClasssFileString = GetWebFile("https://www.unicode.org/Public/UNIDATA/extracted/DerivedBidiClass.txt");
#>
<#
// Get unicode version by searching for the first version in the bidi type file.
System.Text.RegularExpressions.Match versionMatch = new System.Text.RegularExpressions.Regex("[\\d]+\\.[\\d]+\\.[\\d]+").Match(bidiClasssFileString);

if (!versionMatch.Success) {
    throw new Exception("Invalid unicode version");
}

string unicodeVersion = versionMatch.Value;
#>
<#
// process the unicode data.
List<(UInt32, UInt32)> mirrorPairs = new();
foreach (string line in mirroringFileString.Split('\n')) {
    if (line.StartsWith('#')) continue;

    string[] splitLine = line.Split(";");
    if (splitLine.Length < 2) continue;

    mirrorPairs.Add(
        (
            Convert.ToUInt32(splitLine[0].Trim(), 16),
            Convert.ToUInt32(splitLine[1].Trim(), 16)
        )
    );
}

List<(UInt32, UInt32, string)> bracketData = new();
foreach (string line in bracketsFileString.Split('\n')) {
    if (line.StartsWith('#')) continue;

    var noCommentLine = line.Split("#")[0];
    string[] splitLine = noCommentLine.Split(";");

    if (splitLine.Length < 3) continue;

    bracketData.Add(
        (
            Convert.ToUInt32(splitLine[0].Trim(), 16),
            Convert.ToUInt32(splitLine[1].Trim(), 16),
            splitLine[2].Trim() switch {
                "o" => "OPEN",
                "c" => "CLOSE",
                _ => throw new System.ComponentModel.InvalidEnumArgumentException()
            }
        )
    );
}

List<(UInt32, string)> bidiClasss = new();
foreach (string line in bidiClasssFileString.Split('\n')) {
    if (line.StartsWith('#')) continue;

    var noCommentLine = line.Split("#")[0];

    var splitLine = noCommentLine.Split(';');
    if (splitLine.Length < 2) continue;


    UInt32 startIndex, stopIndex;
    if (splitLine[0].Contains('.')) {
        var indices = splitLine[0].Split('.');

        startIndex = Convert.ToUInt32(indices[0].Trim(), 16);
        stopIndex = Convert.ToUInt32(indices[2].Trim(), 16);
    } else {
        startIndex = Convert.ToUInt32(splitLine[0].Trim(), 16);
        stopIndex = startIndex;
    }

    string bidiClassString = splitLine[1].Trim();

    // The default bidi type of a character is "L". Becuase of that, if there's no mapping, a character's type
    // is assumed to be "L", so we don't need to create the mappings. This helps to save some mappings which
    // makes generation and compilation faster.
    if (bidiClassString == "L") continue;

    for (UInt32 currentIndex = startIndex; currentIndex <= stopIndex; ++currentIndex) {
        bidiClasss.Add((currentIndex, bidiClassString));
    }
}
#>
// THIS FILE WAS AUTO-GENERATED DIRECTLY FROM UNICODE DATA, DO NOT EDIT MANUALLY!
namespace UniBidi;

static class BidiMap {
    public const string UNICODE_VERSION = "<#= unicodeVersion #>";

    public static UInt32 GetMirror(UInt32 bidiChar) {
        return bidiChar switch {
<# foreach ((UInt32 bidiChar, UInt32 mirrorChar) in mirrorPairs) {#>
            <#= bidiChar #> => <#= mirrorChar #>,
<# } #>
            _ => bidiChar
        };
    }

    public static BidiClass GetBidiClass(UInt32 bidiChar) {
        return bidiChar switch {
<# foreach ((UInt32 bidiChar, string bidiClass) in bidiClasss) {#>
            <#= bidiChar #> => BidiClass.<#= bidiClass #>,
<# } #>
            _ => BidiClass.L
        };
    }

    public static BracketType GetBracketType(UInt32 bidiChar) {
        return bidiChar switch {
<# foreach ((UInt32 bidiChar, UInt32 _, string bracketType) in bracketData) {#>
            <#= bidiChar #> => BracketType.<#= bracketType #>,
<# } #>
            _ => BracketType.NOT_BRACKET
        };
    }
}