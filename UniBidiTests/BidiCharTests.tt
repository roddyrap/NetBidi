<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Linq" #>
<#@ assembly name="System.Net.Http.dll" #>
<#@ import namespace="System.Net.Http" #>
<#@ assembly name="System.Runtime" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ assembly name="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="System.Text.RegularExpressions.dll" #>
<#
// Get the unicode data from the web.
string GetWebFile(string url) {
    using (HttpClient client = new())
    {
        var httpTask = Task.Run(() => client.GetAsync(url)); 
        httpTask.Wait();

        HttpResponseMessage responseMessage = httpTask.Result ?? throw new Exception("Failed to get unicode file");
        responseMessage.EnsureSuccessStatusCode();
        
        var readTask = Task.Run(() => responseMessage.Content.ReadAsStringAsync());
        readTask.Wait();

        return readTask.Result;
    }
}#>
<#
string bidiCharTestsString = GetWebFile("https://www.unicode.org/Public/UCD/latest/ucd/BidiCharacterTest.txt");
#>
<#
// Actually parse the tests.
List<TestData> allTests = new();
foreach (string line in bidiCharTestsString.Split("\n")) {
    if (line.StartsWith('#')) continue;

    string[] splitLine = line.Split(";");
    if (splitLine.Length < 2) continue;

    string[] resolvedLevelsRaw = splitLine[3].Split(" ");
    List<int> validIndices = new();
    List<uint> embeddingLevels = new();
    for (int cellIndex = 0; cellIndex < resolvedLevelsRaw.Count(); ++cellIndex) {
        string currentCell = resolvedLevelsRaw[cellIndex];
        if (currentCell != "x") {
            validIndices.Add(cellIndex);
            embeddingLevels.Add(Convert.ToUInt32(currentCell));
        }
    }

    allTests.Add(
        new TestData(
            splitLine[0].Split(" ").Select(uniCharString => Convert.ToUInt32(uniCharString, 16)).ToArray(),
            Convert.ToUInt32(splitLine[1], 16),
            Convert.ToUInt32(splitLine[2], 16),
            validIndices.ToArray(),
            embeddingLevels.ToArray(),
            splitLine[4].Split(" ").Select(visualStringIndex => Convert.ToInt32(visualStringIndex)).ToArray()
        )
    );
}
#>
namespace UniBidiTests;

using UniBidi;

public class Tests
{
    [SetUp]
    public void Setup()
    {
    }

<#
for (int currentTestIndex = 0; currentTestIndex < allTests.Count(); ++currentTestIndex) {
    TestData currentTestData = allTests[currentTestIndex];

    string expectedResult = "";
    foreach (int i in currentTestData.validIndices) {
        expectedResult += System.Text.Encoding.UTF32.GetString(BitConverter.GetBytes(currentTestData.testString[i]));
    } #>
    [TestCase(new UInt32[]{<#= string.Join(", ", currentTestData.testString) #>}, TextDirection.<#=IntToDirectionString(currentTestData.paragraphEmbeddingLevel)#>, ExpectedResult="<#=expectedResult#>")]
<#}#>
    public string TestResolveString(UInt32[] input, TextDirection paragraphEmbeddingLevel)
    {
        // The unicode test don't support character mirroring.
        return UniBidi.BidiResolveString(input, paragraphEmbeddingLevel, false);
    }
}
<#+
// For test data and description see the BidiCharacterTest.txt in the UCD.
class TestData {
    public uint[] testString;
    public uint paragraphEmbeddingLevel;
    public uint resolvedParagraphEmbeddingLevel;

    // Indices that were not removed in X9.
    public int[] validIndices;

    // Doesn't contain chars removed in rule X9.
    public uint[] resolvedEmbeddingLevels;

    // The index of each character (not including characters removed by X9) if it were displayed from left
    // to right, after resolving everything.
    public int[] diplayIndices;

    public TestData(uint[] testString, uint paragraphEmbeddingLevel, uint resolvedParagraphEmbeddingLevel,
                    int[] validIndices, uint[] resolvedEmbeddingLevels, int[] diplayIndices) {
        this.testString = testString;
        this.paragraphEmbeddingLevel = paragraphEmbeddingLevel;
        this.resolvedParagraphEmbeddingLevel = resolvedParagraphEmbeddingLevel;
        this.resolvedEmbeddingLevels = resolvedEmbeddingLevels;
        this.diplayIndices = diplayIndices;
        this.validIndices = validIndices;
    }
}

string IntToDirectionString(uint input) {
    return input switch {
        0 => "LTR",
        1 => "RTL",
        2 => "NEUTRAL",
        _ => throw new Exception()
    };
}
#>